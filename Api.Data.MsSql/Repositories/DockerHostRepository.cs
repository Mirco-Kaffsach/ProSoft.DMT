using System.Diagnostics.CodeAnalysis;
using Microsoft.Extensions.Logging;
using ProSoft.DMT.Api.Data.Contracts.Repositories;
using ProSoft.DMT.Contracts.Models;

namespace ProSoft.DMT.Api.Data.MsSql.Repositories;

public sealed class DockerHostRepository : IDockerHostRepository
{
	private readonly ILogger<DockerHostRepository> _logger;
	private readonly AppDbContext _database;

	public DockerHostRepository(ILogger<DockerHostRepository> logger, AppDbContext database)
	{
		_logger = logger;
		_database = database;
	}

	public IQueryable<DockerHost> GetDockerHostQuery()
	{
		_logger.LogInformation("Get all DockerHosts");
		return _database.Set<DockerHost>().AsQueryable();
	}

	#region IDisposable Interface Implementation

	private bool _disposed;

	/// <summary>
	/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
	/// </summary>
	/// <autogeneratedoc />
	[ExcludeFromCodeCoverage]
	public void Dispose()
	{
		this.Dispose(true);
		GC.SuppressFinalize(this);
	}

	/// <summary>
	/// Releases unmanaged and - optionally - managed resources.
	/// </summary>
	/// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
	/// <autogeneratedoc />
	[ExcludeFromCodeCoverage]
	private void Dispose(bool disposing)
	{
		if (!_disposed && disposing)
		{
			// Disposing Logic
		}

		_disposed = true;
	}

	/// <summary>
	/// Finalizes an instance of the <see cref="DockerHostRepository"/> class.
	/// </summary>
	/// <autogeneratedoc />
	[ExcludeFromCodeCoverage]
	~DockerHostRepository()
	{
		this.Dispose(false);
	}

	#endregion
}
